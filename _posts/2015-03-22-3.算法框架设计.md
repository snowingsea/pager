---
layout: post
title:  第三章 OFOA算法框架设计
---
OFOA算法是一种基于义务加速的LTL可满足性检查算法，对于义务这一概念的定义会在后面给出。
本算法基于前文中Wolper提出的tableau方法进行LTL公式的基本展开，但是核心的可满足性检查与Moshe的方法不同。
Moshe在20世纪90年代后期的文章中提出的方法是将LTL公式展开为GBA(Generalized Buchi Automata)，
然后将GBA转化为BA，该BA与给定的LTL等价，通过检查BA接收语言是否为空来判断LTL公式的可满足性。
如果BA接收语言为空，则该LTL公式不可满足，否则，该公式可满足。

OFOA算法直接将LTL公式转为Buchi Automata，相较于Moshe的方法减少了最终自动机的状态个数，
并且在判定可满足的过程中采用义务加速的方式加快判定，
对于无法通过义务加速方式判定的公式通过查找SCC(最强连通图)的方式来确保该算法的完备性。
下面来详细介绍下该算法。

3.1 从LTL到Buchi自动机
-----
首先介绍义务和义务集合的概念。

**义务集合**:给定一个LTL公式φ，定义其义务集合为olg{φ}，如下：

1. olg{true} = {Ø}，并且olg{false} = {{false}};
2. 如果φ = p，那么olg{φ} = {{p}}；
3. 如果φ = Xψ，那么olg{φ} = olg{ψ}；
4. 如果φ = φ<sub>1</sub> ∨ φ<sub>2</sub>，那么olg{φ} = olg{φ<sub>1</sub>} ∪ olg{φ<sub>2</sub>}；
5. 如果φ = φ<sub>1</sub> ∧ φ<sub>2</sub>，那么olg{φ} = {S<sub>1</sub>∪S<sub>2</sub> \| S<sub>1</sub>∈olg{φ<sub>1</sub>} ∧ S<sub>2</sub>∈olg{φ<sub>2</sub>}}；
6. 如果φ = φ<sub>1</sub> U φ<sub>2</sub>或者φ = φ<sub>1</sub> R φ<sub>2</sub>，那么olg{φ} = olg{φ<sub>2</sub>}。

olg{φ}中的每个元素O∈olg{φ}为公式φ的一个义务。
义务标识了公式需要被 无限次满足的属性性质。

一个序列ξ若能无限次满足φ的义务，那么ξ就能满足公式φ，即ξ ╞ φ。
每个LTL公式都有一个和它语义等价的析取范式DNF，LTL公式所描述的是一条无限序列，
DNF格式的公式抽象化地展现了当前状态与下一状态的关系。

如公式a U b，其DNF展开式为b ∨ (a ∧ X(a U b))，若一个无限序列ξ满足公式a U b，
即该序列ξ满足公式b ∨ (a ∧ X(a U b)),则ξ<sup>0</sup>╞ b或(ξ<sup>0</sup>╞ a) ∧ (ξ<sup>1</sup>╞ aUb)。

由此，每个LTL公式都可以通过产生DNF公式的方式得到其对应的迁移系统。
这是LTL转为Buchi自动机的基础步骤，最后一步为接受状态的定义。
对于R-自由的公式，将true定为接受状态，对于U-自由的公式，将所有状态定义为接受状态。
对于非特殊的公式，其接受状态的确定是靠义务集合来驱动的，当义务集合被满足，则当前状态为接收状态。

下面选取一个例子来介绍LTL到Buchi自动机的转化。

选取公式φ<sub>1</sub> = G(a U b ∧ c U d)为例。
φ<sub>1</sub>的析取范式为如下：

φ<sub>1</sub> = (b ∧ d ∧ Xφ<sub>1</sub>) ∨ (a ∧ d ∧ Xφ<sub>2</sub>) ∨ (b ∧ c ∧ Xφ<sub>3</sub>) ∨ (a ∧ c ∧ Xφ<sub>4</sub>)

其中，

φ<sub>2</sub> = a U b ∧ G(a U b ∧ c U d)；

φ<sub>3</sub> = c U d ∧ G(a U b ∧ c U d)；

φ<sub>4</sub> = a U b ∧ c U d ∧ G(a U b ∧ c U d)。

φ<sub>1</sub>、φ<sub>2</sub>、φ<sub>3</sub>、φ<sub>4</sub>都是语义等价的且具有有同样的析取范式。
与公式G(a U b ∧ c U d)等价的Buchi自动机如下图所示。

![与公式G(a U b ∧ c U d)等价的Buchi自动机](/paper/public/img/ltl2buchi.png)

图中图中生成的自动机有4个状态,分别对应四个公式φ<sub>1</sub>、φ<sub>2</sub>、φ<sub>3</sub>、φ<sub>4</sub>。
其中，公式φ对应的状态s<sub>1</sub>为初始状态。
在φ<sub>1</sub>对应的析取范式中有一项为(b ∧ d ∧ Xφ<sub>1</sub>)，
其中X操作符后面的φ<sub>1</sub>代表状态s<sub>1</sub>，因此状态s<sub>1</sub>有一个自回路，边上标注为(b ∧ d)。
根据前面提到的义务集合计算方法，我们可以计算得出四个公式
φ<sub>1</sub>、φ<sub>2</sub>、φ<sub>3</sub>、φ<sub>4</sub>的义务集合，其义务集合是相同的，均为b、d，
可以表示为olg{φ<sub>i</sub>}={b, d}φ<sub>i</sub>(i=1,2,3,4)。
义务标识了公式需要被无限次满足的属性性质,那么若公式φ<sub>i</sub>(i=1,2,3,4)是可满足的，
当且仅当义务集合{b, d}中的每一个义务都可以被无限次满足，即无限次出现。
如图所示，自动机的每个状态包含一个公式和一个过程集合，过程集合用来记录已经被满足的性质，初始状态的过程集合被置为空。
图中，状态s<sub>1</sub>的过程集合P<sub>1</sub>为空集，
状态s<sub>2</sub>的过程集合{d}是由状态s<sub>1</sub>的过程集合和s<sub>1</sub>到s<sub>2</sub>的边a、d的合取计算得到的,
因为a不存在于φ<sub>2</sub>的义务集合{b,d}中，因此状态s<sub>2</sub>的过程集合P<sub>2</sub>为{d}，
状态s<sub>3</sub>的过程集合由状态s<sub>1</sub>的过程集合和s<sub>1</sub>到s<sub>3</sub>的边 b、c 的合取计算得到，
其中c不属于义务集合{b,d}中，因此状态s<sub>3</sub>的过程集合P<sub>3</sub>为b，
同理可计算出状态s<sub>4</sub>对应的状态集合P<sub>4</sub>。
若目前为止义务集合中没有一个属性被满足，那么过程集合表示为{true}，如状态集合P<sub>4</sub>，
指向状态s<sub>4</sub>的边上，公式都不包含在义务集合{b,d}中，因此状态集合P<sub>4</sub>置为{true}。
若某状态对应的过程集合是公式中某一个义务的超集，那么就将该过程集合置为空，
P<sub>1</sub>'=P<sub>4</sub> ∪ {b} = {b, d}得来，
因为olg{φ<sub>1</sub>}是过程集合P<sub>1</sub>'={b, d}的超集。
因此P<sub>1</sub>'被重新置为了空集。

3.2 义务加速检查
-----

在将LTL转为Buchi自动机后，可以检查该自动机接受语言是否为空来判定给定LTL公式的可满足性。
通过分析自动机产生过程可以看出该自动机与Moshe所提出的自动机生成方法的区别，该算法直接得到一个Buchi自动机，
而没有GBA的中间过程，因此减少了时间。
并且在GBA转为BA的过程中会产生许多的冗余状态，该算法也在一定程度上避免了冗余状态的产生。

下面介绍OFOA算法的义务加速检查部分。该过程以下方的定理作为依靠。

**义务加速检查**:假定φ中存在一个义务O∈olg{φ}时一致，那么我们有O<sup>ω</sup> ╞ φ成立。

_例_:公式G(a R b)，根据义务集合的计算方法,该公式的义务为{b},无限序列b<sup>ω</sup>能够无限次消除义务{b}，
因此b<sup>ω</sup> ╞ G(a R b)。

但是该方法是不完备的，如果公式不能通过义务加速检查的方式判定其可满足性，不能直接认定该公式是不可满足的。

_例_:公式F b ∧ G(X ¬b)，通过上一小节中义务集合的计算方法我们可以得到该公式对应的义务集合为{b, ¬b}，
其中包含有不一致的义务
。因此我们不能通过义务加速的方法快速判定该公式的可满足性，同时也不能简单判定该公式不可满足，
无限序列{b}{¬b}<sup>ω</sup>可以满足公式F b ∧ G(X ¬b)。

通过义务集合的一致性来判定公式可满足性只是一种加速方式，这样的可满足性检查时不完备的。

3.3 基于义务集合的可满足性检查
-----

在无法通过义务加速方式来判定的时候，同样有另外一套方法来进行LTL公式的可满足性检查。
工具Aalta_v1.0实现了该方法，通过实验证明了OFOA算法的有效性。

定理如下:

**LTL可满足性检查的中心定理**：令λ为输入公式。
那么SAT(λ)成立当且仅当在T<sub>λ</sub>中存在一个SCC(最强连通图)B，并且在B中存在一个状态ψ，
使得L(B)是ψ中一个义务的超集，即存在O∈olg{φ}使得O ⊆ L(b)成立。

下方的图形化描述可以更好地理解LTL可满足性检查的中心定理。

![中心定理的图形化描述](/paper/public/img/CentralTheorem.png)

3.4 基于 SAT 技术的 LTL 可满足性检查
-----

为了利用SAT求解器的性能进行加速，有一种新的LTL可满足性检查框架，
将上文中的OFOA可满足性检查算法进行优化与改写，在新的框架下实现得到了工具 Aalta_v2.0。

SAT求解器的输入为一个布尔公式，因此需要用义务公式来替代义务集合。

**义务公式**：给定一个LTL公式￼￼φ，其对应的义务公式标记为of(￼￼φ)，其递归定义如下：

1. of(true) = true，并且of(false) = false；
2. 如果φ = p，那么of(φ) = p；
3. 如果φ = Xψ，那么of(φ) = of(ψ)；
4. 如果φ = φ<sub>1</sub> ∨ φ<sub>2</sub>，那么of(φ) = of(φ<sub>1</sub>) ∨ of(φ<sub>2</sub>)；
5. 如果φ = φ<sub>1</sub> ∧ φ<sub>2</sub>，那么of(φ) = of(φ<sub>1</sub>) ∧ of(φ<sub>2</sub>)；
6. 如果φ = φ<sub>1</sub> U φ<sub>2</sub>或者φ = φ<sub>1</sub> R φ<sub>2</sub>，那么of(φ) = of(φ<sub>2</sub>)。

根据以上定义计算得到的义务公式本质上是一个布尔公式。

在进行基于SAT的可满足公式加速时，可以在每个新状态产生时计算其义务公式，
将义务公式作为SAT求解器的输入，若该义务公式可满足，则表明在olg{φ}中存在一致的义务。

对于无法通过加速检查方式判定可满足性的LTL公式，同样利用上一章节的中心定理进行判定，
最终圈的判定问题也可归约为SAT求解问题。
