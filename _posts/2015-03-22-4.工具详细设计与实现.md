---
layout: post
title:  第四章 工具详细设计与实现
---

#### __章节提纲__

* _[4.1 数据结构](#4.1)_
  * _[4.1.1 公式结构](#4.1.1)_
  * _[4.1.2 DNF结构](#4.1.2)_
  * _[4.1.3 存储结构](#4.1.3)_
* _[4.2 核心算法](#4.2)_
  * _[4.2.1 规范化](#4.2.1)_
  * _[4.2.2 化简](#4.2.2)_
  * _[4.2.3 一致性判断](#4.2.3)_
  * _[4.2.4 寻找强连通分量](#4.2.4)_
* _[4.3 Aalta的实现](#4.3)_
  * _[4.3.1 输入](#4.3.1)_
  * _[4.3.2 输出](#4.3.2)_
  * _[4.3.3 语法解析器](#4.3.3)_
  * _[4.3.4 公式构建器](#4.3.4)_
  * _[4.3.5 可满足性检查器](#4.3.5)_

--------------------

<span id="4.1">4.1 数据结构</span>
-----

### <span id="4.1.1">4.1.1 公式结构</span>
我们使用二叉树结构来存储公式结构，其中分支节点存储操作符，叶子节点存储变量值。
假设有公式`(a & b | !b & c) U d`，用二叉树来表示见下图：

![公式树结构](/paper/public/img/formula_tree.png)

该图的根节点为Until算子，右子节点为一个叶子节点，存放变量b，该节点我们也称之为原子节点；
左子节点为一棵以Or算子为根的子树，儿子节点为两棵以And算子为根的子树，
其中右侧子树的左节点是一棵Not算子的子树，该子树左节点为空，用`-`表示，有节点是一个原子节点。

由上可知，要还原公式，只需要先序遍历该二叉树即可。
与此同时，叶子节点为`-`的节点表示空节点，用于表示一元运算符（!、X）的表达式。

### 4.1.2 <span id="4.1.2">DNF结构</span>
公式展开方面，我们使用图结构来表示，进过分析，这是一个带边信息的有向图，且含有重边。
依旧用上面的那个例子，该公式所对应的DNF如下图：

![dnf转移图1](/paper/public/img/dnf_graph1.png)

从上图可知，节点`(a & b | !b & c) U d`有两条自环，自环上的信息依次是`a & b`和`!b & c`，
同时有两条路径指向节点`True`，而边上的信息也是`a & b`和`!b & c`。

然后，该图中的重边是可以去除的，去除重边后等价于下图：

![dnf转移图2](/paper/public/img/dnf_graph2.png)

因此，我们可以用邻接链表来存储整张图，而为了加速查找邻接节点用户合并边，可以使用hash表来替换链表结构。

### 4.1.3 <span id="4.1.3">存储结构</span>
在工具运行过程中，我们需要将公式信息保存下来，这里有几点因素的考虑：

1. DNF公式展开的时候需要判定公式的唯一性（关于公式唯一性的判定将在下一小节深入展开，这里不做详述。）
2. 若公式足够复杂，将会产生极其庞大的中间公式，有可能是内存所无法承受的，这时我们需要借用数据库等外存设备，这也是引入存储层的重要原因。

存储结构方面，我们借用存储公式的树结构，设计以下表：

字段名   | 数据类型 | 字段描述  
-----   | -----  | -----
id      | Number | 公式id，唯一，自增，从1开始
leftId  | Number | 左节点id，0表示空节点
rightId | Number | 右节点id，0表示空节点
oper    | Number | 若子节点id都为0，表示变量编号；否则，表示运算符

其中运算符是事先规定好的枚举；
变量编号从2开始，0表示False，1表示True，此后以遍历顺序编号，若最先遇到变量a，则a的编号为2，而后遇到变量b，则b的编号为3，依次类推。

具体实现上，我们可以使用hash表存储，并使用单例模式

<span id="4.2">4.2 核心算法</span>
-----

### <span id="4.2.1">4.2.1 规范化</span>
在做公式的其他操作之前，先要对公式进行规范化操作，以方便其他操作。
公式的规划化操作包含以下两类操作：

1. 去除<->、->、G和F算子，我们通过以下规则进行改写：
   * `a -> b := !a | b`
   * `a <-> b := (!a | b) & (!b | a)`
   * `G a := False R a`
   * `F a := True U a`
2. 保证!算子只出现在原子前，我们通过以下规则进行改写：
   * `!True => False`
   * `!False => True`
   * `!!a => a`
   * `!(Xa) => X(!a)`
   * `!(G a) => True U !a`
   * `!(F a) => False R !a`
   * `!(a U b) => !a R !b`
   * `!(a R b) => !a U !b`
   * `!(a & b) => !a | !b`
   * `!(a | b) => !a & !b`
   * `!(a->b) => a & !b`
   * `!(a<->b) => (a & !b) | (!a & b)`

### <span id="4.2.2">4.2.2 化简</span>

化简有助于缩短公式长度，最大程度的加速公式判定，因此在做完公式规范化以后，我们使用以下规则对公式进行化简：

1. And算子的化简
   * `True & a & ... => a & ...`
   * `False & a & ... => False`
   * `a & a & ... => a & ...`
   * 若 a 和 b 是冲突的，则 `a & b & ... => False`（由于冲突算法过于冗余，算法过程见附）
2. Or算子的化简
   * `False | a | ... => a | ...`
   * `True | a | ... => True`
   * `a | !a | ... => True`
   * `a | a | ... => a | ...`
   * `a | b U (!a | ... ) => True`
   * `b U (a | ... ) | c U (!a | ...) => True`
   * `a | b R a | ... => a | ...`
   * `a | b U a | ... => b U a | ...`
3. Next算子的化简
   * `X True => True`
   * `X False => False`
4. Until算子的化简
   * `False U a => a`
   * `a U False => False`
   * `a U True => True`
   * `a U (a | ...) => a | ...`
   * `a U (a U b) => a U b`
   * `a U (b U a) => b U a`
   * `a U (b R a) => b R a`
   * `(b R a) U a => a`
   * `(a U b) U a => b U a`
   * `(b U a) U a => b U a`
   * `X a U a => X a | a`
   * `X a U X b => X ( a U b )`
5. Release算子的化简
   * `True R a => a`
   * `a R False => False`
   * `a R True => True`
   * `a R (a & ...) => a & ...`
   * `(a | ...) R a => a`
   * `a R (a R b) => a R b`
   * `a R (b R a) => b R a`
   * `a R (b U a) => b U a`
   * `(b U a | ... ) R a => a`
   * `(a R b) R a => b R a`
   * `(b R a) R a => b R a`
   * `X a R X b => X ( a R b )`
   * `!a R a => False R a`
   * `(b R (!a & ...) & ...) R a => False R a`

### <span id="4.2.3">4.2.3 一致性判断</span>
在工具运行过程中，我们需要判断两个公式是否是同一个公式，
假如已字符串的方式或者树同构的方式比较两个公式的一致性，其算法复杂度将达到O(n)，
当公式一长，所要比较的中间公式一多，其效率将是无法接受的。
所以，我们需要一个可以用来唯一标识公式的方法，并且该标识的计算复杂度小于O(n)。

观察我们的公式结构我们会发现，假如左右子公式存在一个唯一的标识来标记，
那么，对于Not算子、Next算子、Until算子以及Release算子，我们只需要对比操作符和左右子公式的唯一标识就能判定两个公式的一致性了。
但是，对已And算子和Or算子，由于这两个算子符合交换率，即便两个公式树结构不一致，仍然有可能表示同一个公式，
如下图，这两棵公式树都表示公式`a & b & c & d`。

![公式同构](/paper/public/img/formula_isomorphic.png)

因此，我们需要为And算子和Or算子规定一种形态，以防止其多态化。
以And算子为例，假如我们有公式 (a<sub>1</sub> & a<sub>2</sub> & ... & a<sub>n</sub>)，
我们给出构造算法的伪代码：

    Tree build_and_tree(a1, a2, ..., an)
    {
      sort(a1, a2, ..., an);
      tree := make_tree(an);
      for (n = n-1; i > 0; --i)
        tree := make_tree(AND, ai, tree);
      return tree;
    }

举个例子，还是公式`a & b & c & d`，且假如a、b、c、d的唯一标识分别为2、4、1、3时，
通过上述算法进行构造后，树的形态如下图：

![And公式构造](/paper/public/img/build_and_tree.png)

Or算子的构造算法同And算子。

由上述方式，我们可以保证公式的唯一性，
与此同时，由于公式树的叶子节点就是原子变量，我们可以通过变量名来对叶子节点进行唯一标识，
因此，通过数学归纳法可知，我们可以为所有公式做唯一标识，且每次标识，其计算复杂度为O(1)。

这其实是一种以空间换时间的方法，尽管我们的时间复杂度降低了，但是，我们需要将所有的子公式记录下来。
这里，我们只需要记录当前公式的id，左右子公式的id以及操作符oper就可以了，这也是上一小节存储结构中那张存储表的由来。

### <span id="4.2.4">4.2.4 寻找强连通分量</span>
我们使用Tarjan算法来寻找强连通分量[1]，以下简单介绍下Tarjan算法的流程。

Tarjan算法基于深度优先搜索算法（Deep First Search），而每棵搜索树上的子树就是一个强连通分量。
搜索时，我们使用一个堆栈来存储当前搜索树上未处理的节点，回溯时，可以判断栈顶到栈中的节点是否为一个强连通分量。

为此，我们定义DFN(u)为节点u搜索的次序编号(即时间戳)，Low(u)为u或u的子树能够追溯到的最早的栈中节点的次序号。
而当DFN(u)=Low(u)时，以u为根的搜索子树上所有节点是一个强连通分量。

算法伪代码如下：

    tarjan(u)
    {
        DFN[u]=Low[u]=++Index
        Stack.push(u)
        for each (u, v) in E
            if (v is not visted)
                tarjan(v)                // 递归
                Low[u] = min(Low[u], Low[v])
            else if (v in S)
                Low[u] = min(Low[u], DFN[v])
        if (DFN[u] == Low[u])            // 如果节点u是强连通分量的根
            repeat
                v = S.pop                // 将v退栈，为该强连通分量中一个顶点
            until (u== v)
    }

我们可以发现，在运行该算法的过程中，每个节点都被访问了一次，并且只进出堆栈一次，每条边页只被访问了一次，
所以Tarjan算法的时间复杂度为O(V+E)。

求有向图的强连通分量还有另一个算法，叫Kosaraju算法。
Kosaraju是通过对有向图及其逆图两次DFS的来求强连通分量的，其时间复杂度也是O(N+M)。
与Trajan算法相比，Kosaraju算法可能更方便理解，
但是Tarjan只需对原图进行一次DFS，不需要建立逆图，代码实现上更为简洁。
而在实际的测试中，Tarjan算法的运行效率一般也比Kosaraju算法高30%左右。
因此这里我们选择Trajan算法来作强连通分量的实现。

<span id="4.3">4.3 Aalta的实现</span>
-----
有了前两个小节对数据结构和核心算法的介绍之后，这一小节我们来介绍Aalta工具的具体实现。
下图展示了工具Aalta的整体框架：

![Aalta框架图](/paper/public/img/architecture.png)

有框架图中我们可以看出，整个工具分成输入、输出、语法解析器、公式构建器、可满足性检查器这几部分。

### <span id="4.3.1">4.3.1 输入</span>
Aalta的输入是线性时态逻辑公式的字符串，并且可以处理命题逻辑算子（与、或、非、条件、双条件）和时态逻辑算子（Next、Until、Release、Global、Future），
下表列出了工具可以接受的操作符以及在公式中对应的符号。

操作符名称 | 操作符符号
-----    | -----
NOT      | !, ∼
AND      | & , &&
OR       | \|, \|\|
Next     | X
Until    | U
Release  | R,V
Global   | G, []
Future   | F, ⟨⟩
→        | ->
↔        | <->
True     |true, TRUE
False    | false, FALSE

### <span id="4.3.2">4.3.2 输出</span>
Aalta的输出是关于输入公式的可满足性结果(sat/unsat)。
如果公式是可满足的，将给出公式可满足的证据，并且使用小括号来表示无限序列，
比如说，假如输出的证据是“a(xy)”，这其实表示的是无限序列“a(xy)<sup>ω</sup>”。

### <span id="4.3.3">4.3.3 语法解析器</span>
语法解析方面，我们借用FLEX做文法分析、Bison做语法分析。

Flex的前身是lex（Lexical Analyzer Generator），是1975年由Mike Lesk和当时尚在AT&T实习的Eric Schmidt共同完成的基于UNIX环境的词法分析器的生成工具，是UNIX标准应用程序。
无奈由于自身效率低下且存在bug，被人诟病。
后来伯克利实验室的Vern Paxson用C重新写了lex，并命名为Flex（Fast Lexical Analyzer Generator）。
顾名思义，FLEX由于其能高效的处理词法分析而被广泛使用。

Bison的前身是Yacc，是由贝尔实验室的S.C.Johnson基于Knuth的LR分析技术，于1975～1978年写成。
1987年UC Berkeley的Bob Corbett在BSD下重写了Yacc。
再后来GNU Project接管了项目，添加了很多特性，形成了今天的GNU Bison。

借用这两大工具来获取初步的LTL公式对应的抽象语法树结构。


### <span id="4.3.4">4.3.4 公式构建器</span>

### <span id="4.3.5">4.3.5 可满足性检查器</span>


<br />
<br />
<br />
<br />
<br />
<br />

[1] Tarjan, R. E. Depth-first search and linear graph algorithms. SIAM Journal on Computing, 1 (2): 146–160, 1972
