---
layout: post
title:  第四章 工具详细设计与实现
---

4.1 数据结构
-----

### 4.1.1 公式结构
我们使用二叉树结构来存储公式结构，其中分支节点存储操作符，叶子节点存储变量值。
假设有公式`(a & b | !b & c) U d`，用二叉树来表示见下图：

![公式树结构](/paper/public/img/formula_tree.png)

该图的根节点为Until算子，右子节点为一个叶子节点，存放变量b，该节点我们也称之为原子节点；
左子节点为一棵以Or算子为根的子树，儿子节点为两棵以And算子为根的子树，
其中右侧子树的左节点是一棵Not算子的子树，该子树左节点为空，用`-`表示，有节点是一个原子节点。

由上可知，要还原公式，只需要先序遍历该二叉树即可。
与此同时，叶子节点为`-`的节点表示空节点，用于表示一元运算符（!、X）的表达式。

### 4.1.2 DNF结构
公式展开方面，我们使用图结构来表示，进过分析，这是一个带边信息的有向图，且含有重边。
依旧用上面的那个例子，该公式所对应的DNF如下图：

![dnf转移图1](/paper/public/img/dnf_graph1.png)

从上图可知，节点`(a & b | !b & c) U d`有两条自环，自环上的信息依次是`a & b`和`!b & c`，
同时有两条路径指向节点`True`，而边上的信息也是`a & b`和`!b & c`。

然后，该图中的重边是可以去除的，去除重边后等价于下图：

![dnf转移图2](/paper/public/img/dnf_graph2.png)

因此，我们可以用邻接链表来存储整张图，而为了加速查找邻接节点用户合并边，可以使用hash表来替换链表结构。

### 4.1.3 存储结构
在工具运行过程中，我们需要将公式信息保存下来，这里有几点因素的考虑：

1. DNF公式展开的时候需要判定公式的唯一性（关于公式唯一性的判定将在下一小节深入展开，这里不做详述。）
2. 若公式足够复杂，将会产生极其庞大的中间公式，有可能是内存所无法承受的，这时我们需要借用数据库等外存设备，这也是引入存储层的重要原因。

存储结构方面，我们借用存储公式的树结构，设计以下表：

字段名   | 数据类型 | 字段描述  
-----   | -----  | -----
id      | Number | 公式id，唯一，自增，从1开始
leftId  | Number | 左节点id，0表示空节点
rightId | Number | 右节点id，0表示空节点
oper    | Number | 若子节点id都为0，表示变量编号；否则，表示运算符

其中运算符是事先规定好的枚举；
变量以遍历顺序编号，若最先遇到变量a，则a的编号为1，而后遇到变量b，则b的编号为2，依次类推。

4.2 核心算法
-----
